"""Standalone validator for the diabetes chatbot.

This module defines a validator that enforces the behavioral contract
required by the medical chatbot in ``main.py``. The validator executes
locally, relies solely on CPU-bound string checks, and therefore keeps
the overall pipeline fully offline.

No external guardrails-ai dependency required.
"""

from __future__ import annotations

import re
from functools import lru_cache
from typing import Optional
from dataclasses import dataclass


@dataclass
class ValidationResult:
    """Result of a validation check."""
    passed: bool
    message: Optional[str] = None


class MedicalResponsePolicy:
    """Validate responses generated by the diabetes-focused chatbot."""

    REFUSAL_LINE = (
        "I'm your virtual healthcare professional, and I can only assist with diabetes "
        "and health-related questions."
    )

    _GREETING_PATTERN = re.compile(r"^(hi|hello|hey|dear)\b", re.IGNORECASE)
    _DIABETES_KEYWORDS = {
        "a1c",
        "adjustment",
        "autoimmune",
        "basal",
        "beta",
        "beta cell",
        "beta cells",
        "blood",
        "blood glucose",
        "blood sugar",
        "bloodsugar",
        "bolus",
        "carb",
        "carb counting",
        "carbohydrate",
        "carbohydrates",
        "cgm",
        "cgms",
        "continuous glucose monitor",
        "correction factor",
        "dawn phenomenon",
        "dextrose",
        "degludec",
        "detemir",
        "diabetes",
        "diabetic",
        "dka",
        "dpp4",
        "dose",
        "dosing",
        "endocrine",
        "endocrinologist",
        "fasting",
        "glp1",
        "glp-1",
        "fructosamine",
        "gastroparesis",
        "gestational",
        "glargine",
        "glimepiride",
        "glipizide",
        "glucose",
        "glucometer",
        "glulisine",
        "aspart",
        "glyburide",
        "glycaemic",
        "glycemic",
        "homa",
        "hba1c",
        "honeymoon",
        "hyperglycemia",
        "hypoglycemia",
        "insulin to carb ratio",
        "insulin",
        "insulin pen",
        "insulin pump",
        "insulin resistance",
        "insulin sensitivity",
        "insulinpump",
        "injection",
        "injections",
        "ketone",
        "ketone strip",
        "ketones",
        "ketoacidosis",
        "lente",
        "langerhans",
        "lipohypertrophy",
        "lispro",
        "long-acting insulin",
        "lows",
        "metformin",
        "microalbumin",
        "microvascular",
        "needles",
        "mounjaro",
        "nephropathy",
        "neuropathy",
        "pen",
        "oral hypoglycemic",
        "empagliflozin",
        "dapagliflozin",
        "canagliflozin",
        "ozempic",
        "pancreas",
        "pancreatic",
        "pioglitazone",
        "prediabetes",
        "pre-diabetes",
        "retinopathy",
        "rosiglitazone",
        "semaglutide",
        "sensor",
        "sglt2",
        "sglt-2",
        "sitagliptin",
        "sulfonylurea",
        "symptom",
        "symptoms",
        "thiazolidinedione",
        "titration",
        "time in range",
        "tir",
        "tirzepatide",
        "type",
        "type 1",
        "type1",
        "type-1",
        "type 2",
        "type2",
        "type-2",
        "wegovy",
    }
    _GENERAL_HEALTH_KEYWORDS = {
        "albumin",
        "amputation",
        "appointment",
        "bariatric",
        "blood pressure",
        "bloodwork",
        "bp",
        "cardiac",
        "cardiovascular",
        "cholesterol",
        "ckd",
        "clinic",
        "complication",
        "complications",
        "diet",
        "doctor",
        "drug",
        "drugs",
        "exercise",
        "fitness",
        "foot",
        "footcare",
        "glycation",
        "heart",
        "hypertension",
        "kidney",
        "labs",
        "lifestyle",
        "lipid",
        "macrovascular",
        "medication",
        "medications",
        "microvascular",
        "monitor",
        "monitoring",
        "nurse",
        "nutrition",
        "obesity",
        "patient",
        "physician",
        "renal",
        "tablet",
        "therapy",
        "treatment",
        "weight",
        "wound",
    }
    _TOPIC_KEYWORDS = _DIABETES_KEYWORDS.union(_GENERAL_HEALTH_KEYWORDS)
    _FOLLOW_UP_PRONOUNS = {
        "it",
        "its",
        "they",
        "them",
        "those",
        "that",
        "this",
    }
    _FOLLOW_UP_KEYWORDS = {
        "more",
        "details",
        "detail",
        "information",
        "explain",
        "expand",
        "elaborate",
        "continue",
        "next",
        "further",
        "clarify",
        "specifics",
    }
    _OFF_TOPIC_HINTS = {
        "politics",
        "geopolitics",
        "election",
        "president",
        "prime minister",
        "government",
        "policy",
        "legislation",
        "law",
        "laws",
        "football",
        "soccer",
        "basketball",
        "baseball",
        "hockey",
        "tennis",
        "cricket",
        "golf",
        "rugby",
        "olympics",
        "sport",
        "sports",
        "super bowl",
        "superbowl",
        "match",
        "tournament",
        "league",
        "world cup",
        "fifa",
        "nba",
        "nfl",
        "mlb",
        "game",
        "games",
        "gaming",
        "videogame",
        "console",
        "playstation",
        "xbox",
        "switch",
        "movie",
        "movies",
        "cinema",
        "film",
        "netflix",
        "tv show",
        "series",
        "drama",
        "music",
        "song",
        "album",
        "concert",
        "festival",
        "celebrity",
        "actor",
        "actress",
        "singer",
        "rapper",
        "comedian",
        "influencer",
        "gossip",
        "fashion",
        "style",
        "beauty",
        "makeup",
        "hair",
        "perfume",
        "luxury",
        "travel",
        "tourism",
        "vacation",
        "holiday",
        "resort",
        "hotel",
        "restaurant",
        "cuisine",
        "recipe",
        "cook",
        "cooking",
        "chef",
        "foodie",
        "weather",
        "climate",
        "temperature",
        "forecast",
        "storm",
        "capital",
        "country",
        "city",
        "state",
        "continent",
        "geography",
        "map",
        "travelogue",
        "laptop",
        "phone",
        "smartphone",
        "tablet",
        "camera",
        "computer",
        "technology",
        "software",
        "hardware",
        "coding",
        "programming",
        "development",
        "devices",
        "gadget",
        "app",
        "application",
        "startup",
        "business",
        "entrepreneur",
        "marketing",
        "branding",
        "advertising",
        "promotion",
        "finance",
        "banking",
        "investment",
        "stocks",
        "stock",
        "equity",
        "market",
        "forex",
        "bitcoin",
        "crypto",
        "cryptocurrency",
        "nft",
        "economy",
        "inflation",
        "recession",
        "real estate",
        "mortgage",
        "loan",
        "credit",
        "insurance",
        "tax",
        "taxes",
        "accounting",
        "budget",
        "salary",
        "career",
        "job",
        "interview",
        "resume",
        "cv",
        "education",
        "university",
        "college",
        "school",
        "exam",
        "course",
        "class",
        "assignment",
        "homework",
        "science",
        "physics",
        "chemistry",
        "biology",
        "astronomy",
        "space",
        "nasa",
        "rocket",
        "satellite",
        "engineering",
        "robotics",
        "ai",
        "machine learning",
        "history",
        "war",
        "battle",
        "revolution",
        "culture",
        "anthropology",
        "philosophy",
        "psychology",
        "religion",
        "spiritual",
        "faith",
        "church",
        "temple",
        "mosque",
        "prayer",
        "meditation",
        "yoga",
        "mindfulness",
        "relationships",
        "marriage",
        "dating",
        "family",
        "parenting",
        "childcare",
        "pets",
        "dog",
        "cat",
        "animal",
        "wildlife",
        "environment",
        "ecology",
        "sustainability",
        "hobby",
        "craft",
        "art",
        "painting",
        "drawing",
        "photography",
        "writing",
        "poetry",
        "literature",
        "book",
        "novel",
        "comic",
        "manga",
        "anime",
        "board game",
        "card game",
        "puzzle",
        "diy",
        "home improvement",
        "gardening",
        "landscaping",
        "automobile",
        "car",
        "vehicle",
        "motorcycle",
        "truck",
        "transport",
        "aviation",
        "airplane",
        "airport",
        "logistics",
        "shipping",
        "supply chain",
        "manufacturing",
        "factory",
        "industrial",
        "mining",
        "oil",
        "gas",
        "energy",
        "solar",
        "wind",
        "nuclear",
        "power",
        "political science",
        "international relations",
        "diplomacy",
        "news",
        "headline",
        "press",
        "journalism",
        "media",
        "blog",
        "social media",
        "twitter",
        "instagram",
        "facebook",
        "tiktok",
        "snapchat",
        "reddit",
        "forum",
        "influencing",
        "celebrity news",
        "pop culture",
        "memes",
        "viral",
        "trend",
        "lifestyle",
        "traveling",
        "shopping",
        "retail",
        "ecommerce",
        "marketplace",
    }

    def __init__(
        self,
        *,
        max_lines: int = 4,
        max_word_limit: int = 40,
        require_keywords: bool = True,
    ) -> None:
        self.max_lines = max_lines
        self.max_word_limit = max_word_limit
        self.require_keywords = require_keywords

    @staticmethod
    @lru_cache(maxsize=1024)
    def _normalized_tokens(text: str) -> frozenset[str]:
        if not text:
            return frozenset()
        return frozenset(re.findall(r"\w+", text.lower()))

    @staticmethod
    @lru_cache(maxsize=1024)
    def _has_topic_keyword(text: str) -> bool:
        if not text:
            return False
        lowered = text.lower()
        return any(keyword in lowered for keyword in MedicalResponsePolicy._TOPIC_KEYWORDS)

    @staticmethod
    @lru_cache(maxsize=1024)
    def _has_off_topic_hint(text: str) -> bool:
        if not text:
            return False
        lowered = text.lower()
        return any(hint in lowered for hint in MedicalResponsePolicy._OFF_TOPIC_HINTS)

    def _is_off_topic_question(self, question: str) -> bool:
        """Heuristically determine whether the user question is off-topic."""
        if self._has_off_topic_hint(question):
            return True
        if self._has_topic_keyword(question):
            return False
        tokens = self._normalized_tokens(question)
        return not tokens.intersection(self._TOPIC_KEYWORDS)

    def _looks_like_follow_up(
        self,
        question: str,
        previous_question: Optional[str],
        previous_response: Optional[str],
    ) -> bool:
        if not question:
            return False

        q_lower = question.lower().strip()
        if not q_lower:
            return False

        if self._has_off_topic_hint(question) and not self._has_topic_keyword(question):
            return False

        if self._has_topic_keyword(question):
            return True

        token_set = self._normalized_tokens(question)

        if token_set.intersection(self._OFF_TOPIC_HINTS):
            return False

        if self._FOLLOW_UP_PRONOUNS.intersection(token_set):
            return True

        if self._FOLLOW_UP_KEYWORDS.intersection(token_set):
            return True

        follow_up_phrases = (
            "tell me more",
            "more about",
            "what about",
            "what else",
            "how about",
            "anything else",
            "please continue",
        )
        if any(phrase in q_lower for phrase in follow_up_phrases):
            return True

        if previous_question:
            prev_tokens = self._normalized_tokens(previous_question)
            if prev_tokens.intersection(self._TOPIC_KEYWORDS) and token_set.intersection(prev_tokens):
                return True

        if previous_response:
            prev_resp_tokens = self._normalized_tokens(previous_response)
            if prev_resp_tokens.intersection(self._TOPIC_KEYWORDS) and token_set.intersection(prev_resp_tokens):
                return True

        return False

    def validate(
        self,
        value: str,
        question: str,
        *,
        previous_question: Optional[str] = None,
        previous_response: Optional[str] = None,
        previous_passed: Optional[bool] = False,
    ) -> ValidationResult:
        """Validate a response against the medical chatbot policy."""

        if not question:
            return ValidationResult(
                passed=False,
                message="Validator requires the original question."
            )

        text = value.strip()

        if not text:
            return ValidationResult(passed=False, message="Empty response.")

        if text == self.REFUSAL_LINE:
            return ValidationResult(passed=True)

        is_follow_up = bool(
            previous_passed
            and self._looks_like_follow_up(question, previous_question, previous_response)
        )

        lines = [line for line in text.splitlines() if line.strip()]
        word_count = len(re.findall(r"\w+", text))
        response_lower = text.lower()
        question_lower = question.lower()
        is_off_topic = self._is_off_topic_question(question)
        question_has_topic = self._has_topic_keyword(question)

        if (
            self.max_word_limit
            and word_count > self.max_word_limit
            and not is_follow_up
            and is_off_topic
        ):
            return ValidationResult(
                passed=False,
                message=f"Response must stay within {self.max_word_limit} words when the topic is outside diabetes care."
            )

        if len(lines) > self.max_lines and not is_follow_up and is_off_topic:
            return ValidationResult(
                passed=False,
                message=f"Response must be at most {self.max_lines} non-empty lines (got {len(lines)})."
            )

        if self._GREETING_PATTERN.search(lines[0]):
            return ValidationResult(
                passed=False,
                message="Response must not start with a greeting or salutation."
            )

        if is_off_topic and not is_follow_up:
            if question_has_topic:
                is_off_topic = False
            else:
                return ValidationResult(
                    passed=False,
                    message="Detected a non-diabetes question, but the mandated refusal line was not used."
                )

        if self.require_keywords and not is_follow_up and not question_has_topic:
            if not any(keyword in response_lower for keyword in self._TOPIC_KEYWORDS):
                return ValidationResult(
                    passed=False,
                    message="Response must reference diabetes or closely related clinical terms to stay within policy."
                )

        return ValidationResult(passed=True)


def enforce_medical_policy(
    response_text: str,
    question: str,
    *,
    validator: Optional[MedicalResponsePolicy] = None,
    previous_question: Optional[str] = None,
    previous_response: Optional[str] = None,
    previous_passed: Optional[bool] = False,
) -> tuple[bool, str, Optional[str]]:
    """Apply the medical response validator and normalize the output.

    Returns a tuple of ``(is_valid, sanitized_response, failure_message)``.
    When validation fails, the sanitized response falls back to the
    mandated refusal line while ``failure_message`` describes the issue.
    """

    active_validator = validator or MedicalResponsePolicy()
    result = active_validator.validate(
        response_text,
        question,
        previous_question=previous_question,
        previous_response=previous_response,
        previous_passed=previous_passed,
    )

    if result.passed:
        return True, response_text.strip(), None

    failure_message = result.message or "Validation failed."
    return False, MedicalResponsePolicy.REFUSAL_LINE, failure_message


__all__ = [
    "MedicalResponsePolicy",
    "enforce_medical_policy",
]

