"""Standalone validator for the diabetes chatbot.

This module defines a validator that enforces the behavioral contract
required by the medical chatbot in ``main.py``. The validator executes
locally, relies solely on CPU-bound string checks, and therefore keeps
the overall pipeline fully offline.

No external guardrails-ai dependency required.
"""

from __future__ import annotations

import re
from typing import Optional
from dataclasses import dataclass


@dataclass
class ValidationResult:
    """Result of a validation check."""
    passed: bool
    message: Optional[str] = None


class MedicalResponsePolicy:
    """Validate responses generated by the diabetes-focused chatbot."""

    REFUSAL_LINE = (
        "I'm your virtual healthcare professional, and I can only assist with diabetes "
        "and health-related questions."
    )

    _GREETING_PATTERN = re.compile(r"^(hi|hello|hey|dear)\b", re.IGNORECASE)
    _DIABETES_KEYWORDS = {
        "diabetes",
        "diabetic",
        "glucose",
        "blood",
        "sugar",
        "bloodsugar",
        "blood sugar",
        "blood glucose",
        "a1c",
        "hba1c",
        "insulin",
        "metformin",
        "symptom",
        "symptoms",
        "sign",
        "signs",
        "diagnosis",
        "diagnose",
        "diagnosed",
        "screening",
        "complication",
        "complications",
        "treatment",
        "treat",
        "therapy",
        "medication",
        "medications",
        "meds",
        "drug",
        "drugs",
        "dose",
        "dosing",
        "pump",
        "pumps",
        "insulinpump",
        "injection",
        "injections",
        "needle",
        "needles",
        "ketone",
        "ketones",
        "hypoglycemia",
        "hyperglycemia",
        "ketoacidosis",
        "dka",
        "fasting",
        "diet",
        "exercise",
        "workout",
        "activity",
        "lifestyle",
        "protein",
        "carb",
        "carbs",
        "carbohydrate",
        "carbohydrates",
        "sglt2",
        "glp1",
        "ozempic",
        "wegovy",
        "type",
        "type1",
        "type2",
        "neuropathy",
        "retinopathy",
        "nephropathy",
        "monitor",
        "monitoring",
        "glucometer",
        "cgm",
        "cgms",
        "sensor",
        "pancreas",
        "pancreatic",
        "beta",
        "endocrine",
        "endocrinologist",
        "foot",
        "ulcer",
        "wound",
        "patient",
        "medical",
        "health",
        "oral",
        "tablet",
        "pill",
        "complication",
        "complications",
    }
    _FOLLOW_UP_PRONOUNS = {
        "it",
        "its",
        "they",
        "them",
        "those",
        "that",
        "this",
    }
    _FOLLOW_UP_KEYWORDS = {
        "more",
        "details",
        "detail",
        "information",
        "explain",
        "expand",
        "elaborate",
        "continue",
        "next",
        "further",
        "clarify",
        "specifics",
    }
    _OFF_TOPIC_HINTS = {
        "politics",
        "election",
        "football",
        "soccer",
        "cricket",
        "sport",
        "sports",
        "game",
        "games",
        "match",
        "league",
        "tournament",
        "super",
        "bowl",
        "superbowl",
        "movie",
        "music",
        "weather",
        "travel",
        "capital",
        "country",
        "city",
        "stock",
        "bitcoin",
        "crypto",
        "technology",
    }

    def __init__(
        self,
        *,
        max_lines: int = 4,
        require_keywords: bool = True,
    ) -> None:
        self.max_lines = max_lines
        self.require_keywords = require_keywords

    def _is_off_topic_question(self, question: str) -> bool:
        """Heuristically determine whether the user question is off-topic."""
        tokens = set(re.findall(r"\w+", question.lower()))
        if tokens.intersection(self._OFF_TOPIC_HINTS):
            return True
        return not tokens.intersection(self._DIABETES_KEYWORDS)

    def _looks_like_follow_up(
        self,
        question: str,
        previous_question: Optional[str],
        previous_response: Optional[str],
    ) -> bool:
        if not question:
            return False

        q_lower = question.lower().strip()
        if not q_lower:
            return False

        tokens = re.findall(r"\w+", q_lower)
        token_set = set(tokens)

        if token_set.intersection(self._OFF_TOPIC_HINTS):
            return False

        if self._FOLLOW_UP_PRONOUNS.intersection(token_set):
            return True

        if self._FOLLOW_UP_KEYWORDS.intersection(token_set):
            return True

        follow_up_phrases = (
            "tell me more",
            "more about",
            "what about",
            "what else",
            "how about",
            "anything else",
            "please continue",
        )
        if any(phrase in q_lower for phrase in follow_up_phrases):
            return True

        if previous_question:
            prev_tokens = set(re.findall(r"\w+", previous_question.lower()))
            if prev_tokens.intersection(self._DIABETES_KEYWORDS) and token_set.intersection(prev_tokens):
                return True

        if previous_response:
            prev_resp_tokens = set(re.findall(r"\w+", previous_response.lower()))
            if prev_resp_tokens.intersection(self._DIABETES_KEYWORDS) and token_set.intersection(prev_resp_tokens):
                return True

        return False

    def validate(
        self,
        value: str,
        question: str,
        *,
        previous_question: Optional[str] = None,
        previous_response: Optional[str] = None,
        previous_passed: Optional[bool] = False,
    ) -> ValidationResult:
        """Validate a response against the medical chatbot policy."""
        
        if not question:
            return ValidationResult(
                passed=False,
                message="Validator requires the original question."
            )

        text = value.strip()

        if not text:
            return ValidationResult(passed=False, message="Empty response.")

        if text == self.REFUSAL_LINE:
            return ValidationResult(passed=True)

        is_follow_up = bool(
            previous_passed
            and self._looks_like_follow_up(question, previous_question, previous_response)
        )

        lines = [line for line in text.splitlines() if line.strip()]
        if len(lines) > self.max_lines:
            return ValidationResult(
                passed=False,
                message=f"Response must be at most {self.max_lines} non-empty lines (got {len(lines)})."
            )

        if self._GREETING_PATTERN.search(lines[0]):
            return ValidationResult(
                passed=False,
                message="Response must not start with a greeting or salutation."
            )

        if self._is_off_topic_question(question) and not is_follow_up:
            return ValidationResult(
                passed=False,
                message="Detected a non-diabetes question, but the mandated refusal line was not used."
            )

        if self.require_keywords and not is_follow_up:
            lowered = text.lower()
            if not any(keyword in lowered for keyword in self._DIABETES_KEYWORDS):
                return ValidationResult(
                    passed=False,
                    message="Response must reference diabetes-related terms to stay within policy."
                )

        return ValidationResult(passed=True)


def enforce_medical_policy(
    response_text: str,
    question: str,
    *,
    validator: Optional[MedicalResponsePolicy] = None,
    previous_question: Optional[str] = None,
    previous_response: Optional[str] = None,
    previous_passed: Optional[bool] = False,
) -> tuple[bool, str, Optional[str]]:
    """Apply the medical response validator and normalize the output.

    Returns a tuple of ``(is_valid, sanitized_response, failure_message)``.
    When validation fails, the sanitized response falls back to the
    mandated refusal line while ``failure_message`` describes the issue.
    """

    active_validator = validator or MedicalResponsePolicy()
    result = active_validator.validate(
        response_text,
        question,
        previous_question=previous_question,
        previous_response=previous_response,
        previous_passed=previous_passed,
    )

    if result.passed:
        return True, response_text.strip(), None

    failure_message = result.message or "Validation failed."
    return False, MedicalResponsePolicy.REFUSAL_LINE, failure_message


__all__ = [
    "MedicalResponsePolicy",
    "enforce_medical_policy",
]

